create a config file
put the destinations there
load destinations





pub const BOOT_STARTER: u32 = 1000;

pub struct Servers {
    pub peer_list: HashMap<u32, (PeerId, Multiaddr)>,
    pub sender: HashMap<u32, tokio::sync::mpsc::Sender<UserEvent>>,
}

impl Servers {
    /// Creates a new `Servers` instance.
    pub fn new() -> Self {
        Servers {
            peer_list: HashMap::new(),
            sender: HashMap::new(),
        }
    }

    /// Initializes the servers and creates channels for communication.
    ///
    /// # Arguments
    ///
    /// * `self` - The `Servers` instance to initialize.
    /// * `number` - The number of servers to initialize.
    ///
    /// # Returns
    ///
    /// `Ok(())` if the servers were successfully initialized, or an error if initialization failed.
    pub async fn init_servers(&mut self, number: u32) -> Result<(), Box<dyn std::error::Error>> {

        for i in 0..number {
            let listening_address = create_listen_address(i as u32);
            let (client, event_receiver, peer_id) = 
                P2PServer::initialize_server(listening_address.clone(), None).await?;

            // Create the channel for the user to send events to the server
            let (user_sender, user_receiver) = tokio::sync::mpsc::channel::<UserEvent>(100);
            self.sender.insert(i,user_sender);
            client_receiver_behaviour(client, event_receiver, user_receiver).await;

            let peer_addr = define_peer_addr(peer_id, listening_address.clone());
            self.peer_list.insert(i, (peer_id.clone(), peer_addr));
        }
        Ok(())
    }

    /// Connects the servers to each other.
    ///
    /// # Arguments
    ///
    /// * `self` - The `Servers` instance to connect.
    ///
    /// # Returns
    ///
    /// `Ok(())` if the servers were successfully connected, or an error if connection failed.
    pub async fn connect_servers(&mut self) -> Result<(), Box<dyn std::error::Error>> {

        let number_servers = self.peer_list.len();

        // Grab each server and dial the other servers
        for i in 0..number_servers {
            let current_sender = self.sender.get(&(i as u32)).unwrap();

            for j in 0..number_servers {
                if i != j {
                    let (peer_id, peer_addr) = self.peer_list.get(&(j as u32)).unwrap();
                    current_sender.send(UserEvent::DialPeer(peer_id.clone(), peer_addr.clone()))
                        .await.expect("Could not dial the peer");
                }
            }
        }
        Ok(())
    }
}

fn create_listen_address(number: u32) -> String {
    return format!("/ip4/127.0.0.1/tcp/{}", 40820 + number);
}

/// Define the peer address for the given `PeerId` and `Multiaddr`.
///
/// # Arguments
///
/// * `peer_id` - The `PeerId` to include in the address.
/// * `peer_addr` - The `Multiaddr` to include in the address.
///
/// # Returns
///
/// The `Multiaddr` representing the peer address.
fn define_peer_addr(peer_id: PeerId, peer_addr: String) -> Multiaddr {
    let peer_addr: Multiaddr = format!("{}/p2p/{}", peer_addr, peer_id.to_base58()).parse::<Multiaddr>().unwrap();
    return peer_addr;
}


pub async fn generate_keys(num: u32) -> Vec<Keypair> {

    let mut file = File::create("boot_nodes.txt").await.unwrap();
    let mut keys = Vec::new();
    
    for i in BOOT_STARTER..(BOOT_STARTER + num) {
        let bytes = transform_u32_to_array_of_u8(i);

        let local_key = identity::Keypair::ed25519_from_bytes(bytes).unwrap();
        let peer_id = PeerId::from(local_key.public()).to_string();
        let mut buffer = Cursor::new(peer_id + "\n") ;

        file.write_all_buf(&mut buffer).await.expect("Failed to write generated peer_id to file");
        keys.push(local_key);
    }

    keys
}

pub fn transform_u32_to_array_of_u8(x:u32) -> [u8;32] {
    let b1 : u8 = ((x >> 24) & 0xff) as u8;
    let b2 : u8 = ((x >> 16) & 0xff) as u8;
    let b3 : u8 = ((x >> 8) & 0xff) as u8;
    let b4 : u8 = (x & 0xff) as u8;

    let mut bytes = [0u8; 32];
    bytes[0] = b1;
    bytes[1] = b2;
    bytes[2] = b3;
    bytes[3] = b4;
    return bytes
}
